<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Melodeus Control</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            overflow: hidden;
            transition: background 0.3s;
        }
        
        body.stt-off {
            background: #252530;
        }
        
        body.stt-off .sidebar {
            background: #2a2a35;
        }
        
        body.stt-off .cards-bar,
        body.stt-off .input-bar,
        body.stt-off .transcript-header {
            background: #2a2a35;
        }
        
        body.stt-off .speaker-card {
            opacity: 0.6;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
        }
        
        /* LEFT SIDEBAR */
        .sidebar {
            width: 220px;
            background: #16213e;
            border-right: 1px solid #0f3460;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow-y: auto;
            max-height: 100vh;
        }
        
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #0f3460;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #1a4a7e;
            border-radius: 3px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #2a5a9e;
        }
        
        .sidebar-header {
            padding: 12px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sidebar-header h1 {
            font-size: 14px;
            font-weight: 600;
            color: #e94560;
        }
        
        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .connection-dot.connected { background: #4CAF50; }
        .connection-dot.disconnected { background: #f44336; }
        
        .sidebar-section {
            padding: 10px 12px;
            border-bottom: 1px solid #0f3460;
        }
        
        .sidebar-section h3 {
            font-size: 10px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        
        .sidebar-section select,
        .sidebar-section input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            background: #0f3460;
            border: 1px solid #1a1a4e;
            border-radius: 4px;
            color: #eee;
            font-size: 12px;
            margin-bottom: 6px;
        }
        
        .sidebar-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            padding: 6px 8px;
            background: #0f3460;
            border: none;
            border-radius: 4px;
            color: #ccc;
            font-size: 11px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
        }
        
        .sidebar-btn:hover { background: #1a4a7e; color: #fff; }
        .sidebar-btn.active { background: #e94560; color: #fff; }
        .sidebar-btn.danger { background: #8b0000; }
        .sidebar-btn.danger:hover { background: #c0392b; }
        .sidebar-btn.warning { background: #b8860b; }
        .sidebar-btn.warning:hover { background: #d4a017; }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 11px;
            color: #aaa;
        }

        .slider-row {
            display: flex;
            flex-direction: column;
            padding: 4px 0;
            font-size: 11px;
            color: #aaa;
            gap: 4px;
        }

        .slider-row input[type="range"] {
            width: 100%;
            height: 4px;
            cursor: pointer;
        }
        
        /* Audio level meters */
        .level-meter-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        
        .level-label {
            font-size: 10px;
            color: #888;
            width: 40px;
        }
        
        .level-meter {
            flex: 1;
            height: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #0f3460;
        }
        
        .level-bar {
            height: 100%;
            width: 0%;
            transition: width 0.05s ease-out;
            border-radius: 3px;
        }
        
        .level-bar.input-level {
            background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 50%, #CDDC39 75%, #FFC107 90%, #f44336 100%);
        }
        
        .level-bar.output-level {
            background: linear-gradient(90deg, #2196F3 0%, #03A9F4 50%, #00BCD4 75%, #009688 100%);
        }
        
        .peak-indicator {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #fff;
            opacity: 0.8;
            left: 0%;
            transition: left 0.05s ease-out, opacity 0.5s ease-out;
        }
        
        .level-meter {
            position: relative;
        }

        .toggle-switch {
            width: 32px;
            height: 16px;
            background: #333;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .toggle-switch.on { background: #4CAF50; }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.2s;
        }
        
        .toggle-switch.on::after { left: 18px; }
        
        /* LEARNED SPEAKERS in sidebar */
        .learned-speakers-list {
            max-height: none;
            overflow-y: auto;
            flex: 1;
        }
        
        .learned-speaker-row {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 0;
            font-size: 11px;
        }
        
        .learned-speaker-row input[type="checkbox"] {
            width: 12px;
            height: 12px;
        }
        
        .learned-speaker-row input[type="text"] {
            flex: 1;
            padding: 3px 5px;
            font-size: 10px;
            margin: 0;
        }
        
        .learned-speaker-row .mini-btn {
            padding: 2px 5px;
            font-size: 9px;
            background: #4CAF50;
            border: none;
            border-radius: 2px;
            color: white;
            cursor: pointer;
        }

        .learned-speaker-row .mini-btn.danger {
            background: #8b0000;
        }

        .learned-speaker-row .mini-btn.danger:hover {
            background: #c0392b;
        }
        
        .merge-row {
            display: flex;
            gap: 4px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #0f3460;
        }
        
        .merge-row input {
            flex: 1;
            padding: 3px 5px;
            font-size: 10px;
        }
        
        .merge-row .mini-btn {
            padding: 2px 6px;
            font-size: 9px;
            background: #2196F3;
            border: none;
            border-radius: 2px;
            color: white;
            cursor: pointer;
        }
        
        /* Stats at bottom of sidebar */
        .sidebar-stats {
            margin-top: auto;
            padding: 10px 12px;
            border-top: 1px solid #0f3460;
            font-size: 10px;
            color: #666;
        }
        
        .sidebar-stats div {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
        }
        
        /* MAIN CONTENT */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        /* CHARACTER CARDS */
        .cards-bar {
            display: flex;
            gap: 6px;
            padding: 8px 10px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .speaker-card {
            padding: 8px 10px;
            border-radius: 6px;
            min-width: 90px;
            background: #0f3460;
            border: 2px solid transparent;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .speaker-card:hover { background: #1a4a7e; }
        
        .speaker-card.active {
            background: #4CAF50;
            border-color: #81C784;
        }
        
        .speaker-card.thinking {
            background: #FF9800;
            animation: pulse 1.5s infinite;
        }
        
        .speaker-card.next-speaker {
            border-color: #e94560;
            box-shadow: 0 0 8px rgba(233, 69, 96, 0.4);
        }
        
        .speaker-card.next-speaker::before {
            content: "NEXT";
            position: absolute;
            top: -6px;
            right: -6px;
            background: #e94560;
            color: white;
            font-size: 9px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .speaker-card h3 {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 3px;
            white-space: nowrap;
            letter-spacing: 0.3px;
        }
        
        .speaker-card .status-text {
            font-size: 10px;
            color: #aaa;
            display: block;
        }
        
        .speaker-card.active .status-text,
        .speaker-card.thinking .status-text {
            color: rgba(255,255,255,0.9);
        }
        
        .card-actions {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 5px;
        }
        
        .card-btn {
            padding: 6px 10px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.15);
            color: #ccc;
            font-weight: 600;
            transition: all 0.15s;
        }
        
        .card-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.05); }
        .card-btn:active { transform: scale(0.95); }
        .card-btn.next { background: #9C27B0; color: white; }
        .card-btn.next:hover { background: #AB47BC; }
        .card-btn.trigger { background: #2196F3; color: white; }
        .card-btn.trigger:hover { background: #42A5F5; }
        .card-btn.trigger-large {
            background: #2196F3;
            color: white;
            width: 100%;
            padding: 8px 0;
            font-size: 16px;
        }
        .card-btn.trigger-large:hover { background: #42A5F5; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* MESSAGE INPUT BAR */
        .input-bar {
            display: flex;
            gap: 6px;
            padding: 8px 12px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            flex-shrink: 0;
        }
        
        .input-bar input[type="text"] {
            padding: 8px 10px;
            background: #0f3460;
            border: 1px solid #1a1a4e;
            border-radius: 4px;
            color: #eee;
            font-size: 13px;
        }
        
        .input-bar input[type="text"]:first-child {
            width: 120px;
            flex-shrink: 0;
        }
        
        .input-bar input[type="text"]:nth-child(2) {
            flex: 1;
        }
        
        .input-bar button {
            padding: 8px 14px;
            background: #e94560;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .input-bar button:hover { background: #ff6b6b; }
        
        /* TRANSCRIPT */
        .transcript-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .transcript-header {
            padding: 6px 12px;
            background: #0f3460;
            font-size: 11px;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .transcript {
            flex: 1;
            overflow-y: auto;
            padding: 10px 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .message {
            max-width: 80%;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.4;
            position: relative;
        }
        
        .message.user {
            align-self: flex-end;
            background: #0f3460;
            border-bottom-right-radius: 2px;
        }
        
        .message.ai {
            align-self: flex-start;
            background: #1a4a7e;
            border-bottom-left-radius: 2px;
        }
        
        .message.interim {
            opacity: 0.6;
            font-style: italic;
        }
        
        .speaker-name {
            font-size: 10px;
            font-weight: 600;
            color: #e94560;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .message.user .speaker-name { color: #81C784; }
        
        .message-content {
            color: #ddd;
        }
        
        .message-actions {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            gap: 4px;
        }
        
        .message:hover .message-actions { display: flex; }
        
        .message-actions button {
            padding: 2px 5px;
            font-size: 9px;
            background: rgba(0,0,0,0.3);
            border: none;
            border-radius: 2px;
            color: #aaa;
            cursor: pointer;
        }
        
        .message-actions button:hover { background: rgba(0,0,0,0.5); color: #fff; }
        
        .thinking-indicator {
            display: inline-flex;
            gap: 3px;
            margin-left: 8px;
        }
        
        .thinking-indicator span {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: #e94560;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        
        .thinking-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .thinking-indicator span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f3460; }
        ::-webkit-scrollbar-thumb { background: #1a4a7e; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #2a5a8e; }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- LEFT SIDEBAR -->
        <div class="sidebar">
            <div class="sidebar-header">
            <div class="connection-dot" id="connection-dot"></div>
                <h1>üéôÔ∏è Melodeus</h1>
        </div>
            
            <div class="sidebar-section">
                <h3>Director Mode</h3>
                <select id="director-mode" onchange="setDirectorMode(this.value)">
                    <option value="off">üö´ Off</option>
                    <option value="same_model">üîÑ Same Model</option>
                    <option value="director">üé≠ Director</option>
                </select>
            </div>
            
            <div class="sidebar-section">
                <h3>Context</h3>
                <select id="context-selector" onchange="switchContext(this.value)">
                </select>
                <button class="sidebar-btn" onclick="resetContext()">üîÑ Reset Context</button>
                <button class="sidebar-btn" onclick="duplicateContext()">üìã Save as New Context</button>
            </div>
            
            <div class="sidebar-section">
                <h3>Controls</h3>
                <div class="toggle-row">
                    <span>STT Active</span>
                    <div class="toggle-switch" id="stt-toggle" onclick="toggleSTT()"></div>
        </div>
                <div class="toggle-row">
                    <span>Mute While AI Speaks</span>
                    <div class="toggle-switch on" id="mute-while-speaking-toggle" onclick="toggleMuteWhileSpeaking()"></div>
    </div>
                <div class="toggle-row">
                    <span>Interruptions</span>
                    <div class="toggle-switch" id="interruptions-toggle" onclick="toggleInterruptions()"></div>
        </div>
                <button class="sidebar-btn danger" onclick="forceInterrupt()">üõë Force Interrupt</button>
                <button class="sidebar-btn" onclick="resetFingerprints()">üîÑ Reset Voices</button>
                <button class="sidebar-btn warning" onclick="restartServer()">üîÉ Restart Server</button>
                <div class="toggle-row">
                    <span>Learning Mode</span>
                    <div class="toggle-switch on" id="learning-mode-toggle" onclick="toggleLearningMode()"></div>
                </div>
                <div class="slider-row">
                    <span>Threshold: <span id="threshold-value">0.50</span></span>
                    <input type="range" id="threshold-slider" min="0.30" max="0.80" step="0.05" value="0.50"
                           onchange="updateThreshold(this.value)" oninput="document.getElementById('threshold-value').textContent = parseFloat(this.value).toFixed(2)">
                </div>
    </div>
    
            <div class="sidebar-section">
                <h3>Audio Levels</h3>
                <div class="level-meter-row">
                    <span class="level-label">üé§ In</span>
                    <div class="level-meter">
                        <div class="level-bar input-level" id="input-level-bar"></div>
                        <div class="peak-indicator" id="input-peak-indicator"></div>
                    </div>
                </div>
                <div class="level-meter-row">
                    <span class="level-label">üîä Out</span>
                    <div class="level-meter">
                        <div class="level-bar output-level" id="output-level-bar"></div>
                        <div class="peak-indicator" id="output-peak-indicator"></div>
                    </div>
                </div>
    </div>
    
            <div class="sidebar-section" id="learned-speakers-section" style="display: none;">
                <h3>Learned Speakers</h3>
                <div class="learned-speakers-list" id="learned-speakers-list">
        </div>
    </div>
    
            <div class="sidebar-stats">
                <div><span>Generation:</span><strong id="generation-count">0</strong></div>
                <div><span>Messages:</span><strong id="message-count">0</strong></div>
    </div>
    </div>
    
        <!-- MAIN CONTENT -->
        <div class="main-content">
            <!-- Character Cards -->
            <div class="cards-bar" id="status-panel">
                <div id="user-card" class="speaker-card">
                    <h3>üë§ USER</h3>
                    <span class="status-text">Idle</span>
        </div>
    </div>
    
            <!-- Message Input -->
            <div class="input-bar">
                <input type="text" id="speaker-name" placeholder="Speaker" value="USER" />
                <input type="text" id="text-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter')sendTextMessage()" />
                <button onclick="sendTextMessage()">üì§ Send</button>
    </div>
    
            <!-- Transcript -->
    <div class="transcript-container">
        <div class="transcript-header">
                    <span>Conversation</span>
            <span id="typing-indicator" style="display: none;">
                <span class="thinking-indicator">
                    <span></span><span></span><span></span>
                </span>
            </span>
        </div>
        <div id="transcript" class="transcript"></div>
            </div>
        </div>
    </div>
    
    <script>
        let ws = null;
        let sttActive = true;
        let interruptionsEnabled = false;
        let directorMode = 'off';
        let lastAiSpeaker = null;
        let availableCharacters = [];
        let currentMessages = {};
        let streamAccumulators = {};  // Track accumulated text per session for streaming
        let messageCount = 0;
        let isConnected = false;
        let learnedSpeakers = [];
        let learnedSpeakersExpanded = true;
        let reconnectTimer = null;
        const RECONNECT_DELAY_MS = 500;
        
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const dot = document.getElementById('connection-dot');
            if (connected) {
                dot.classList.add('connected');
                dot.classList.remove('disconnected');
            } else {
                dot.classList.remove('connected');
                dot.classList.add('disconnected');
            }
        }
        
        function scheduleReconnect() {
            if (reconnectTimer !== null) return;
            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                connect();
            }, RECONNECT_DELAY_MS);
        }

        function connect() {
            const hostname = window.location.hostname || 'localhost';
            ws = new WebSocket('ws://' + hostname + ':8795');
            
            ws.onopen = () => {
                console.log('Connected');
                if (reconnectTimer !== null) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }
                updateConnectionStatus(true);
                ws.send(JSON.stringify({ type: 'ui_ready', data: { client_id: 'web-ui' } }));
            };
            
            ws.onclose = () => {
                console.log('Disconnected');
                updateConnectionStatus(false);
                scheduleReconnect();
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false);
                scheduleReconnect();
            };
            
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleMessage(msg);
            };
        }
        
        function handleMessage(msg) {
            switch(msg.type) {
                case 'speaker_status':
                    updateSpeakerStatus(msg.data);
                    break;
                case 'transcription':
                    updateTranscription(msg.data);
                    break;
                case 'ai_stream':
                    handleAIStream(msg.data);
                    break;
                case 'ai_stream_start':
                    handleAIStreamStart(msg.data);
                    break;
                case 'ai_stream_chunk':
                    handleAIStreamChunk(msg.data);
                    break;
                case 'ai_stream_end':
                    handleAIStreamEnd(msg.data);
                    break;
                case 'ai_stream_correction':
                    handleAIStreamCorrection(msg.data);
                    break;
                case 'state_sync':
                    handleStateSync(msg.data);
                    break;
                case 'system_status':
                    updateSystemStatus(msg.data);
                    break;
                case 'history':
                case 'conversation_history':
                    loadHistory(msg.data);
                    break;
                case 'message_updated':
                    handleMessageUpdated(msg.data);
                    break;
                case 'message_deleted':
                    handleMessageDeleted(msg.data);
                    break;
                case 'playing_prepared_statement':
                    handlePreparedStatement(msg.data);
                    break;
                case 'available_characters':
                    updateAvailableCharacters(msg.data);
                    break;
                case 'last_ai_speaker_changed':
                    updateLastAiSpeaker(msg.data.character);
                    break;
                case 'mute_while_speaking_changed':
                    muteWhileSpeaking = msg.data.enabled;
                    updateMuteWhileSpeakingToggle();
                    break;
                case 'audio_levels':
                    updateAudioLevels(msg.data);
                    break;
                case 'contexts_list':
                    console.log('üîç WebSocket received contexts_list message:', msg);
                    updateContextsList(msg.data);
                    break;
                case 'context_switched':
                    updateActiveContext(msg.data);
                    break;
                case 'context_duplicated':
                    alert(`Created new context: ${msg.data.new_context}`);
                    break;
                case 'context_deleted':
                    console.log(`Deleted context: ${msg.data.context_name}`);
                    break;
                case 'learned_speakers':
                    learnedSpeakers = msg.data.speakers || [];
                    updateLearnedSpeakersUI();
                    break;
                case 'fingerprint_settings':
                    updateFingerprintSettings(msg.data);
                    break;
                case 'speaker_renamed':
                    learnedSpeakers = msg.data.known_speakers || [];
                    updateLearnedSpeakersUI();
                    updateTranscriptSpeakerNames(msg.data.old_id, msg.data.new_name);
                    break;
                case 'speakers_merged':
                    learnedSpeakers = msg.data.known_speakers || [];
                    updateLearnedSpeakersUI();
                    msg.data.merged_ids.forEach(oldId => {
                        updateTranscriptSpeakerNames(oldId, msg.data.target_name);
                    });
                    break;
                case 'fingerprints_reset':
                    learnedSpeakers = [];
                    updateLearnedSpeakersUI();
                    break;
            }
        }
        
        function updateSpeakerStatus(data) {
            document.querySelectorAll('.speaker-card').forEach(card => {
                const isNext = card.classList.contains('next-speaker');
                card.className = 'speaker-card' + (isNext ? ' next-speaker' : '');
                const statusText = card.querySelector('.status-text');
                if (statusText) statusText.textContent = 'Idle';
            });
            
            if (data.thinking_sound && data.pending_speaker) {
                const card = document.getElementById(`${data.pending_speaker.toLowerCase()}-card`);
                if (card) {
                    card.classList.add('thinking');
                    const statusText = card.querySelector('.status-text');
                    if (statusText) statusText.textContent = 'Thinking...';
                }
            }
            
            if (data.current_speaker) {
                const card = document.getElementById(`${data.current_speaker.toLowerCase()}-card`);
                if (card) {
                    card.classList.add('active');
                    const statusText = card.querySelector('.status-text');
                    if (statusText) statusText.textContent = data.is_speaking ? 'Speaking' : 'Processing';
                }
            }
            
            if (data.is_processing && data.pending_speaker && !data.thinking_sound) {
                const card = document.getElementById(`${data.pending_speaker.toLowerCase()}-card`);
                if (card && !data.current_speaker) {
                    card.classList.add('thinking');
                    const statusText = card.querySelector('.status-text');
                    if (statusText) statusText.textContent = 'Processing...';
                }
            }
        }
        
        function updateTranscription(data) {
            const transcript = document.getElementById('transcript');
            
            if (data.is_interim) {
                let interim = document.getElementById('interim-msg');
                if (!interim) {
                    interim = document.createElement('div');
                    interim.id = 'interim-msg';
                    interim.className = 'message user interim';
                    transcript.appendChild(interim);
                }
                interim.innerHTML = `
                    <div class="speaker-name">${escapeHtml(data.speaker || 'USER')}</div>
                    <div class="message-content">${escapeHtml(data.text)}</div>
                `;
                transcript.scrollTop = transcript.scrollHeight;  // Auto-scroll to show interim
                document.getElementById('typing-indicator').style.display = 'inline';
            } else if (data.is_final) {
                const interim = document.getElementById('interim-msg');
                if (interim) interim.remove();
                document.getElementById('typing-indicator').style.display = 'none';
                
                const msg = document.createElement('div');
                msg.className = 'message user';
                msg.innerHTML = `
                    <div class="speaker-name">${escapeHtml(data.speaker || 'USER')}</div>
                    <div class="message-content">${escapeHtml(data.text)}</div>
                    ${data.message_id ? `
                        <div class="message-actions">
                            ${data.has_audio ? `<button onclick="replayAudio('${data.message_id}', 'user')" title="Replay audio">üîä</button>` : ''}
                            <button onclick="editMessage('${data.message_id}')">‚úèÔ∏è</button>
                            <button onclick="deleteMessage('${data.message_id}')">üóëÔ∏è</button>
                        </div>
                    ` : ''}
                `;
                if (data.message_id) msg.id = data.message_id;
                transcript.appendChild(msg);
                transcript.scrollTop = transcript.scrollHeight;
                messageCount++;
                document.getElementById('message-count').textContent = messageCount;
            }
        }
        
        function handleAIStream(data) {
            const transcript = document.getElementById('transcript');
            let msg = currentMessages[data.session_id];

            if (!msg) {
                // Create new message
                msg = document.createElement('div');
                msg.className = 'message ai';
                msg.setAttribute('data-session-id', data.session_id);
                msg.innerHTML = `
                    <div class="speaker-name">${data.speaker}</div>
                    <div class="message-content"></div>
                `;
                if (data.message_id) msg.id = data.message_id;
                transcript.appendChild(msg);
                currentMessages[data.session_id] = msg;
                streamAccumulators[data.session_id] = '';  // Initialize accumulator
            }

            // Accumulate text (append new chunk)
            if (data.text) {
                streamAccumulators[data.session_id] = (streamAccumulators[data.session_id] || '') + data.text;
            }

            // Update content with accumulated text
            const content = msg.querySelector('.message-content');
            if (content) {
                content.textContent = streamAccumulators[data.session_id] || '';
            }

            // Scroll to bottom
            transcript.scrollTop = transcript.scrollHeight;

            // If complete, add actions and clean up
            if (data.is_complete) {
                if (data.message_id) msg.id = data.message_id;
                const existingActions = msg.querySelector('.message-actions');
                if (!existingActions) {
                    const actions = document.createElement('div');
                    actions.className = 'message-actions';
                    actions.innerHTML = `
                        ${data.has_audio ? `<button onclick="replayAudio('${data.message_id}', 'ai')" title="Replay audio">üîä</button>` : ''}
                        <button onclick="editMessage('${data.message_id}')">‚úèÔ∏è</button>
                        <button onclick="deleteMessage('${data.message_id}')">üóëÔ∏è</button>
                    `;
                    msg.appendChild(actions);
                }
                delete currentMessages[data.session_id];
                delete streamAccumulators[data.session_id];  // Clean up accumulator
                messageCount++;
            document.getElementById('message-count').textContent = messageCount;
            }
        }
        
        function handleAIStreamStart(data) {
                const transcript = document.getElementById('transcript');
                const msg = document.createElement('div');
            msg.className = `message ai`;
            msg.setAttribute('data-session-id', data.session_id);
            msg.innerHTML = `
                <div class="speaker-name">${data.speaker}</div>
                <div class="message-content"></div>
            `;
            msg.id = data.message_id;
                transcript.appendChild(msg);
                transcript.scrollTop = transcript.scrollHeight;
            currentMessages[data.session_id] = msg;
        }
        
        function handleAIStreamChunk(data) {
            let msg = currentMessages[data.session_id];
            if (!msg) {
                msg = document.createElement('div');
                msg.className = `message ai`;
                msg.setAttribute('data-session-id', data.session_id);
                msg.innerHTML = `
                    <div class="speaker-name">${data.speaker}</div>
                    <div class="message-content"></div>
                `;
                msg.id = data.message_id;
                document.getElementById('transcript').appendChild(msg);
                currentMessages[data.session_id] = msg;
                streamAccumulators[data.session_id] = '';  // Initialize accumulator
            }
            // Accumulate text
            if (data.text) {
                streamAccumulators[data.session_id] = (streamAccumulators[data.session_id] || '') + data.text;
            }
            const content = msg.querySelector('.message-content');
            if (content) {
                content.textContent = streamAccumulators[data.session_id] || '';
                document.getElementById('transcript').scrollTop = document.getElementById('transcript').scrollHeight;
            }
        }

        function handleAIStreamEnd(data) {
            const msg = currentMessages[data.session_id];
            if (msg) {
                const actions = document.createElement('div');
                actions.className = 'message-actions';
                actions.innerHTML = `
                    ${data.has_audio ? `<button onclick="replayAudio('${data.message_id}', 'ai')" title="Replay audio">üîä</button>` : ''}
                    <button onclick="editMessage('${data.message_id}')">‚úèÔ∏è</button>
                    <button onclick="deleteMessage('${data.message_id}')">üóëÔ∏è</button>
                `;
                msg.appendChild(actions);
                delete currentMessages[data.session_id];
                delete streamAccumulators[data.session_id];  // Clean up accumulator
                messageCount++;
                document.getElementById('message-count').textContent = messageCount;
            }
        }
        
        function handleAIStreamCorrection(data) {
            const msg = document.querySelector(`[data-session-id="${data.session_id}"]`);
            if (msg) {
                const content = msg.querySelector('.message-content');
                if (content) {
                    content.textContent = data.corrected_text;
                    if (data.was_interrupted) {
                        content.textContent += ' [interrupted]';
                        msg.style.opacity = '0.7';
                    }
                }
            }
        }
        
        function handleStateSync(data) {
            if (data.stt_active !== undefined) {
                sttActive = data.stt_active;
                updateSTTToggle();
            }
            if (data.interruptions_enabled !== undefined) {
                interruptionsEnabled = data.interruptions_enabled;
                updateInterruptionsToggle();
            }
            if (data.director_mode !== undefined) {
                directorMode = data.director_mode;
                document.getElementById('director-mode').value = directorMode;
            }
            if (data.last_ai_speaker !== undefined) {
                updateLastAiSpeaker(data.last_ai_speaker);
            }
            if (data.mute_while_speaking !== undefined) {
                muteWhileSpeaking = data.mute_while_speaking;
                updateMuteWhileSpeakingToggle();
            }
        }
        
        function updateSystemStatus(data) {
            if (data.stt_active !== undefined) {
            sttActive = data.stt_active;
                updateSTTToggle();
            }
            if (data.current_generation !== undefined) {
                document.getElementById('generation-count').textContent = data.current_generation;
            }
        }
        
        // Peak level tracking
        let inputPeakLevel = 0;
        let outputPeakLevel = 0;
        let inputPeakTime = 0;
        let outputPeakTime = 0;
        const PEAK_HOLD_MS = 2000;  // Hold peak for 2 seconds
        const PEAK_DECAY_RATE = 0.02;  // Decay rate per update after hold
        
        function updateAudioLevels(data) {
            const inputBar = document.getElementById('input-level-bar');
            const outputBar = document.getElementById('output-level-bar');
            const inputPeak = document.getElementById('input-peak-indicator');
            const outputPeak = document.getElementById('output-peak-indicator');
            const now = Date.now();
            
            if (inputBar && data.input !== undefined) {
                inputBar.style.width = (data.input * 100) + '%';
                // Update peak
                if (data.input >= inputPeakLevel) {
                    inputPeakLevel = data.input;
                    inputPeakTime = now;
                } else if (now - inputPeakTime > PEAK_HOLD_MS) {
                    inputPeakLevel = Math.max(data.input, inputPeakLevel - PEAK_DECAY_RATE);
                }
                if (inputPeak) {
                    inputPeak.style.left = (inputPeakLevel * 100) + '%';
                }
            }
            if (outputBar && data.output !== undefined) {
                outputBar.style.width = (data.output * 100) + '%';
                // Update peak
                if (data.output >= outputPeakLevel) {
                    outputPeakLevel = data.output;
                    outputPeakTime = now;
                } else if (now - outputPeakTime > PEAK_HOLD_MS) {
                    outputPeakLevel = Math.max(data.output, outputPeakLevel - PEAK_DECAY_RATE);
                }
                if (outputPeak) {
                    outputPeak.style.left = (outputPeakLevel * 100) + '%';
                }
            }
        }
        
        function loadHistory(data) {
            const transcript = document.getElementById('transcript');
            transcript.innerHTML = '';
            
            const turns = data.turns || data.history || [];
            if (turns.length > 0) {
                turns.forEach((turn, index) => {
                const msg = document.createElement('div');
                    const isUser = turn.role === 'user';
                    msg.className = `message ${isUser ? 'user' : 'ai'}`;
                    const msgId = `msg_${index}`;
                    msg.id = msgId;
                    
                    const speakerName = turn.speaker_name || (isUser ? 'USER' : turn.character || 'AI');
                    const role = isUser ? 'user' : 'ai';
                msg.innerHTML = `
                    <div class="speaker-name">${speakerName}</div>
                    <div class="message-content">${escapeHtml(turn.content)}</div>
                    ${turn.editable ? `
                        <div class="message-actions">
                                <button onclick="replayAudio('${msgId}', '${role}')" title="Replay audio">üîä</button>
                                <button onclick="editMessage('${msgId}')">‚úèÔ∏è</button>
                                <button onclick="deleteMessage('${msgId}')">üóëÔ∏è</button>
                        </div>
                    ` : ''}
                `;
                transcript.appendChild(msg);
                });
                messageCount = turns.length;
            document.getElementById('message-count').textContent = messageCount;
                // Delay scroll to ensure DOM has rendered
                requestAnimationFrame(() => {
            transcript.scrollTop = transcript.scrollHeight;
                });
            }
        }
        
        function handleMessageUpdated(data) {
            const msg = document.getElementById(data.id);
            if (msg) {
                // Update text content if provided
                if (data.new_text) {
                    const content = msg.querySelector('.message-content');
                    if (content) content.textContent = data.new_text;
                }
                // Update speaker name if provided (from batch diarization corrections)
                if (data.speaker) {
                    const speakerEl = msg.querySelector('.speaker-name');
                    if (speakerEl) {
                        speakerEl.textContent = data.speaker.toUpperCase();
                        console.log(`üîÑ Speaker corrected: ${data.id} -> ${data.speaker}`);
                    }
                }
            }
        }
        
        function handleMessageDeleted(data) {
            const msg = document.getElementById(data.id);
            if (msg) msg.remove();
        }
        
        function handlePreparedStatement(data) {
                const transcript = document.getElementById('transcript');
                const msg = document.createElement('div');
            msg.className = 'message ai';
            msg.style.background = '#2a2a4a';
                msg.style.fontStyle = 'italic';
            msg.innerHTML = `<div class="message-content">üìú Playing "${data.statement_name}" for ${data.speaker}...</div>`;
                transcript.appendChild(msg);
                transcript.scrollTop = transcript.scrollHeight;
        }
        
        function updateAvailableCharacters(data) {
            availableCharacters = data.characters || data || [];
            const panel = document.getElementById('status-panel');
            
            // Remove old character cards (keep user card)
            panel.querySelectorAll('.speaker-card:not(#user-card)').forEach(c => c.remove());
            
            availableCharacters.forEach(char => {
                const card = document.createElement('div');
                card.id = `${char.name.toLowerCase()}-card`;
                card.className = 'speaker-card';
                card.onclick = (e) => { if (e.target === card || e.target.tagName !== 'BUTTON') setNextAiSpeaker(char.name); };
                card.style.cursor = 'pointer';
                card.innerHTML = `
                    <h3>${char.name}</h3>
                    <span class="status-text">Idle</span>
                    <div class="card-actions">
                        <button class="card-btn trigger-large" onclick="event.stopPropagation(); triggerCharacter('${char.name}')">‚ñ∂</button>
                </div>
            `;
                panel.appendChild(card);
            });
            
            if (lastAiSpeaker) updateLastAiSpeaker(lastAiSpeaker);
        }
        
        function updateLastAiSpeaker(character) {
            lastAiSpeaker = character;
            document.querySelectorAll('.speaker-card').forEach(card => {
                card.classList.remove('next-speaker');
            });
            if (character) {
                const card = document.getElementById(`${character.toLowerCase()}-card`);
                if (card) card.classList.add('next-speaker');
            }
        }
        
        function setNextAiSpeaker(character) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_last_ai_speaker',
                    data: { character: character }
                }));
            }
        }
        
        function triggerCharacter(character) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'trigger_speaker',
                    data: { speaker: character }
                }));
            }
        }
        
        function updateContextsList(data) {
            console.log('üîç updateContextsList received:', data);
            console.log('üîç Number of contexts:', data.contexts ? data.contexts.length : 0);
            if (data.contexts) {
                console.log('üîç Context names:', data.contexts.map(c => c.name));
            }
            const selector = document.getElementById('context-selector');
            selector.innerHTML = '';
            if (data.contexts) {
                data.contexts.forEach(ctx => {
                    const opt = document.createElement('option');
                    opt.value = ctx.name;
                    opt.textContent = ctx.name;
                    if (ctx.is_active) opt.selected = true;
                    selector.appendChild(opt);
                });
            }
        }
        
        function updateActiveContext(data) {
            document.getElementById('context-selector').value = data.context_name;
        }
        
        function switchContext(name) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'switch_context',
                    data: { context_name: name }
                }));
            }
        }
        
        function resetContext() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (confirm('Reset context to original? This will clear current conversation.')) {
                    ws.send(JSON.stringify({ type: 'reset_context' }));
                }
            }
        }

        function duplicateContext() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const customName = prompt('Enter name for new context (leave empty for auto-generated):');
                if (customName !== null) {  // null means user clicked Cancel
                    ws.send(JSON.stringify({
                        type: 'duplicate_context',
                        data: { new_name: customName || null }
                    }));
                }
            }
        }

        // CONTROLS
        function toggleSTT() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'stt_control',
                    data: { action: sttActive ? 'pause' : 'resume' }
                }));
            }
        }
        
        function updateSTTToggle() {
            const toggle = document.getElementById('stt-toggle');
            if (sttActive) {
                toggle.classList.add('on');
                document.body.classList.remove('stt-off');
            } else {
                toggle.classList.remove('on');
                document.body.classList.add('stt-off');
            }
        }

        let muteWhileSpeaking = true;  // Default on

        function toggleMuteWhileSpeaking() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_mute_while_speaking',
                    data: { enabled: !muteWhileSpeaking }
                }));
            }
        }

        function updateMuteWhileSpeakingToggle() {
            const toggle = document.getElementById('mute-while-speaking-toggle');
            if (muteWhileSpeaking) {
                toggle.classList.add('on');
            } else {
                toggle.classList.remove('on');
            }
        }

        function toggleInterruptions() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ 
                    type: 'toggle_interruptions', 
                    data: { enabled: !interruptionsEnabled }
                }));
            }
        }
        
        function updateInterruptionsToggle() {
            const toggle = document.getElementById('interruptions-toggle');
                if (interruptionsEnabled) {
                toggle.classList.add('on');
                } else {
                toggle.classList.remove('on');
            }
        }
        
        function forceInterrupt() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'force_interrupt' }));
            }
        }
        
        function setDirectorMode(mode) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ 
                    type: 'set_director_mode', 
                    data: { mode: mode }
                }));
            }
        }
        
        function resetFingerprints() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (confirm('Reset all learned voices?')) {
                    ws.send(JSON.stringify({ type: 'reset_fingerprints' }));
                    learnedSpeakers = [];
                    updateLearnedSpeakersUI();
                }
            }
        }

        function restartServer() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (confirm('Restart melodeus server? The page will reload automatically.')) {
                    ws.send(JSON.stringify({ type: 'restart' }));
                    // Show a message and attempt to reconnect after a delay
                    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0d1b2a;color:#e0e0e0;font-family:sans-serif;"><div style="text-align:center;"><h1>üîÉ Restarting...</h1><p>Reconnecting in 5 seconds...</p></div></div>';
                    setTimeout(() => location.reload(), 5000);
                }
            }
        }

        let learningModeEnabled = true;

        function toggleLearningMode() {
            learningModeEnabled = !learningModeEnabled;
            const toggle = document.getElementById('learning-mode-toggle');
            if (learningModeEnabled) {
                toggle.classList.add('on');
                } else {
                toggle.classList.remove('on');
            }
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_learning_mode',
                    data: { enabled: learningModeEnabled }
                }));
            }
        }

        function updateThreshold(value) {
            const threshold = parseFloat(value);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_fingerprint_threshold',
                    data: { threshold: threshold }
                }));
            }
        }

        function updateFingerprintSettings(data) {
            if (data.learning_mode !== undefined) {
                learningModeEnabled = data.learning_mode;
                const toggle = document.getElementById('learning-mode-toggle');
                if (learningModeEnabled) {
                    toggle.classList.add('on');
                } else {
                    toggle.classList.remove('on');
                }
            }
            if (data.threshold !== undefined) {
                document.getElementById('threshold-slider').value = data.threshold;
                document.getElementById('threshold-value').textContent = data.threshold.toFixed(2);
            }
        }

        // LEARNED SPEAKERS
        function updateLearnedSpeakersUI() {
            const section = document.getElementById('learned-speakers-section');
            const list = document.getElementById('learned-speakers-list');
            
            if (learnedSpeakers.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            let html = learnedSpeakers.map(speaker => {
                let displayName = speaker;
                if (speaker.startsWith('unknown_speaker_')) {
                    displayName = 'User ' + speaker.replace('unknown_speaker_', '');
                }
                return `
                    <div class="learned-speaker-row" data-speaker-id="${speaker}">
                        <input type="checkbox" id="merge-${speaker}" onchange="updateMergeBtn()">
                        <span style="min-width:50px;color:#888;font-size:10px;">${displayName}</span>
                        <input type="text" value="${speaker.startsWith('unknown_speaker_') ? '' : speaker}"
                               placeholder="Name..." id="rename-${speaker}">
                        <button class="mini-btn" onclick="renameSpeaker('${speaker}')">‚úì</button>
                        <button class="mini-btn danger" onclick="deleteSpeaker('${speaker}')" title="Delete speaker">‚úï</button>
                </div>
            `;
            }).join('');
            
            if (learnedSpeakers.length >= 2) {
                html += `
                    <div class="merge-row">
                        <input type="text" id="merge-target" placeholder="Merged name">
                        <button class="mini-btn" id="merge-btn" onclick="mergeSelected()" disabled>üîÄ</button>
                    </div>
                `;
            }
            list.innerHTML = html;
        }
        
        function updateMergeBtn() {
            const checked = document.querySelectorAll('.learned-speaker-row input[type="checkbox"]:checked');
            const btn = document.getElementById('merge-btn');
            if (btn) btn.disabled = checked.length < 2;
        }
        
        function renameSpeaker(oldId) {
            const input = document.getElementById('rename-' + oldId);
            const newName = input.value.trim();
            if (!newName) return alert('Enter a name');

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'rename_speaker',
                    data: { old_id: oldId, new_name: newName }
                }));
            }
        }

        function deleteSpeaker(speakerId) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'delete_speaker',
                    data: { speaker_id: speakerId }
                }));
                // Optimistically remove from local list
                learnedSpeakers = learnedSpeakers.filter(s => s !== speakerId);
                updateLearnedSpeakersUI();
            }
        }

        function mergeSelected() {
            const selected = [];
            document.querySelectorAll('.learned-speaker-row input[type="checkbox"]:checked').forEach(cb => {
                selected.push(cb.closest('.learned-speaker-row').dataset.speakerId);
            });
            const targetName = document.getElementById('merge-target').value.trim();
            
            if (selected.length < 2) return alert('Select at least 2 speakers');
            if (!targetName) return alert('Enter a name for merged speaker');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'merge_speakers',
                    data: { speaker_ids: selected, target_name: targetName }
                }));
            }
        }
        
        function updateTranscriptSpeakerNames(oldName, newName) {
            let displayOld = oldName;
            if (oldName.startsWith('unknown_speaker_')) {
                displayOld = 'User ' + oldName.replace('unknown_speaker_', '');
            }
            
            document.querySelectorAll('.message .speaker-name').forEach(el => {
                if (el.textContent.toUpperCase() === displayOld.toUpperCase()) {
                    el.textContent = newName.toUpperCase();
                }
            });
        }
        
        // MESSAGES
        function sendTextMessage() {
            const speakerInput = document.getElementById('speaker-name');
            const textInput = document.getElementById('text-input');
            const speaker = speakerInput.value.trim() || 'USER';
            const text = textInput.value.trim();
            
            if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
            
                ws.send(JSON.stringify({
                    type: 'send_text_message',
                data: { speaker_name: speaker, text: text }
                }));
                textInput.value = '';
        }
        
        function editMessage(msgId) {
            const msg = document.getElementById(msgId);
            if (!msg) return;
            
            const content = msg.querySelector('.message-content');
            const currentText = content.textContent;
            const newText = prompt('Edit message:', currentText);
            
            if (newText !== null && newText !== currentText) {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'edit_message',
                        data: { message_id: msgId, new_text: newText }
                    }));
                }
            }
        }
        
        function deleteMessage(msgId) {
            if (!confirm('Delete this message?')) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'delete_message',
                    data: { message_id: msgId }
                }));
            }
        }

        function replayAudio(msgId, role) {
            // role is 'user' or 'ai'
            const audioUrl = `/audio_archive/${role}/${msgId}.wav`;
            const audio = new Audio(audioUrl);
            audio.onerror = () => {
                console.log(`Audio not found: ${audioUrl}`);
            };
            audio.play().catch(err => {
                console.log(`Failed to play audio: ${err}`);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize
        connect();
    </script>
</body>
</html>
